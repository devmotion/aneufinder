#' Bin the genome
#'
#' Please see functions \code{\link{fixedWidthBins}} and \code{\link{variableWidthBins}} for further details.
#'
#' @name binning
NULL


#' Make fixed-width bins
#'
#' Make fixed-width bins based on given bin size.
#'
#' @param bamfile A BAM file from which the header is read to determine the chromosome lengths. If a \code{bamfile} is specified, option \code{assembly} is ignored.
#' @param assembly An assembly from which the chromosome lengths are determined. Please see \code{\link[GenomeInfoDb]{fetchExtendedChromInfoFromUCSC}} for available assemblies. This option is ignored if \code{bamfile} is specified. Alternatively a data.frame generated by \code{\link[GenomeInfoDb]{fetchExtendedChromInfoFromUCSC}}.
#' @param binsizes A vector of bin sizes in base pairs.
#' @param chromosomes A subset of chromosomes for which the bins are generated.
#' @param blacklist A \code{\link{GRanges}} object or a BED file with blacklisted regions. Reads falling into those regions will be discarded.
#' @return A \code{list()} of \code{\link{GRanges}} objects with fixed-width bins.
#' @author Aaron Taudt
#' @importFrom Rsamtools BamFile
#' @export
#'
#'@examples
#'## Make fixed-width bins of size 500kb and 1Mb
#'bins <- fixedWidthBins(assembly='mm10', chromosome.format='NCBI', binsizes=c(5e5,1e6))
#'bins
#'
fixedWidthBins <- function(bamfile=NULL, assembly=NULL, binsizes=1e6, chromosomes=NULL, blacklist=NULL) {
  ### Get chromosome lengths ###
  chroms2use <- chromosomeLengths(bamfile, assembly, chromosomes)

  ### Making fixed-width bins ###
  bins.list <- list()
  for (binsize in binsizes) {
    ptm <- startTimedMessage("Making fixed-width bins for bin size ", binsize, " ...")
    chrom.lengths.floor <- floor(chroms2use$length / binsize) * binsize
    bins <- unlist(GenomicRanges::tileGenome(chrom.lengths.floor, tilewidth=binsize), use.names=FALSE)
    bins <- bins[end(bins) > 0] # no chromosomes that are smaller than binsize
    if (any(width(bins)!=binsize)) {
      stop("tileGenome failed")
    }
    # seqlengths(bins) <- as.integer(chrom.lengths[names(seqlengths(bins))])
    seqlengths(bins) <- chroms2use$length

    ## Remove bins overlapping blacklisted regions
    bins <- blacklistGRanges(bins, blacklist)

    ## Add bins to list of fixed-width bins
    bins.list[[as.character(binsize)]] <- bins

    skipped.chroms <- setdiff(seqlevels(bins), as.character(unique(seqnames(bins))))
    if (length(skipped.chroms)>0) {
      warning("The following chromosomes were skipped because they are smaller than binsize ", binsize, ": ", toString(skipped.chroms))
    }

    stopTimedMessage(ptm)
  }

  return(bins.list)
}


#' Make variable-width bins
#' 
#' Make variable-width bins based on a reference BAM file. This can be a simulated file (produced by \code{\link{simulateReads}} and aligned with your favourite aligner) or a real reference.
#' 
#' Variable-width bins are produced by first binning the reference BAM file with fixed-width bins and selecting the desired number of reads per bin as the (non-zero) maximum of the histogram. A new set of bins is then generated such that every bin contains the desired number of reads.
#' 
#' @param reads A \code{\link{GRanges}} with reads. See \code{\link{bam2GRanges}} and \code{\link{bed2GRanges}}.
#' @param binsizes A vector with binsizes. Resulting bins will be close to the specified binsizes.
#' @param chromosomes A subset of chromosomes for which the bins are generated.
#' @return A \code{list()} of \code{\link{GRanges}} objects with variable-width bins.
#' @author Aaron Taudt
#' @export
#'
#'@examples
#'## Get an example BED file with single-cell-sequencing reads
#'bedfile <- system.file("extdata", "KK150311_VI_07.bam.bed.gz", package="AneuFinderData")
#'## Read the file into a GRanges object
#'reads <- bed2GRanges(bedfile, assembly='mm10', chromosomes=c(1:19,'X','Y'),
#'                     min.mapq=10, remove.duplicate.reads=TRUE)
#'## Make variable-width bins of size 500kb and 1Mb
#'bins <- variableWidthBins(reads, binsizes=c(5e5,1e6))
#'## Plot the distribution of binsizes
#'hist(width(bins[['1e+06']]), breaks=50)
#'
variableWidthBins <- function(reads, binsizes, chromosomes=NULL) {
  ### Get desired subset of chromosomes
  chroms.names <- filterChromosomes(reads, chromosomes)

  ## Drop unwanted seqlevels
#  reads <- reads[seqnames(reads) %in% chroms2use]
  seqlevelsStyle(reads) <- seqlevelsStyle(chroms.names)
  reads <- keepSeqlevels(reads, chroms.names)
  reads <- cleanSeqlevels(reads)

  ## Make fixed width bins
  ptm <- startTimedMessage("Binning reads in fixed-width windows ...")
  binned.list <- suppressMessages( binReads(reads, assembly=chroms2use, binsizes=binsizes, calc.complexity=FALSE, chromosomes=NULL) )
  stopTimedMessage(ptm)

  ## Sort the reads
  strand(reads) <- '*'
  reads <- sort(reads)

  ## Loop over binsizes
  bins.list <- list()
  for (i1 in 1:length(binsizes)) {
    binsize <- binsizes[i1]
    ptm <- startTimedMessage("Making variable-width windows for bin size ", binsize, " ...")
    binned <- binned.list[[i1]]
    ## Get mode of histogram
    tab <- table(binned$counts)
    modecount <- as.integer(names(which.max(tab[names(tab)!=0])))
    ## Pick only every modecount read
    subreads <- GRangesList()
    skipped.chroms <- character()
    for (chrom in chroms2use$chromosome) {
      reads.chr <- reads[seqnames(reads)==chrom]
      if (length(reads.chr) >= modecount) {
        idx <- seq(modecount, length(reads.chr), by=modecount)
        subreads[[chrom]] <- reads.chr[idx]
      } else {
        skipped.chroms[chrom] <- chrom
      }
    }
    if (length(skipped.chroms)>0) {
      warning("The following chromosomes were skipped because they are smaller than binsize ", binsize, ": ", paste0(skipped.chroms, collapse=', '))
    }
    subreads <- unlist(subreads, use.names=FALSE)
    ## Adjust length of reads to get consecutive bins
    subreads <- resize(subreads, width=1)
    ## Make new bins
    bins <- gaps(subreads, start=1L, end=seqlengths(subreads)-1L) # gaps until seqlengths-1 because we have to add 1 later to get consecutive bins
    bins <- bins[strand(bins)=='*']
    end(bins) <- end(bins) + 1
    ## We don't want incomplete bins at the end
    bins.split <- split(bins, seqnames(bins))
    bins.split <- endoapply(bins.split, function(x) { x[-length(x)] })
    bins <- unlist(bins.split, use.names=FALSE)
    ## Remove skipped chromosomes
 #   bins <- bins[!seqnames(bins) %in% skipped.chroms]
    bins <- keepSeqlevels(bins, setdiff(seqlevels(bins), skipped.chroms))

    bins.list[[as.character(binsize)]] <- bins
    stopTimedMessage(ptm)
  }

  return(bins.list)

}
